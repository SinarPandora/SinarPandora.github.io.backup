---
layout: post
title: Scala 类型系统03：自类型标记与结构化类型
---
>  我们可以用 this 来指代调用该方法的实例。一般情况下，我们不需要显示地使用 this，但如果作用域内存在同名变量时，显示使用 this 有助于消除二义性。

## 1 自类型标记

>
>  `自类型标记 (self-type annotation )`可以帮助我们完成两件事：
>
>  * 创建 this 的别名
>  * 声明某特征/类必须引入另一特征/类

先来看第一点，自类型标记可以起到为 this 起别名的功能：

```scala
// 下文的 self v 并不是关键字，可以把它换成任何合法的关键字
class C1 { self =>
  def talk(message: String) = println(s"C1 talk: $message")
  class C2 {
    class C3 {
      def talk(message: String) = self.talk(s"C3 talk: $message")
    }
  }
}

val c1 = new C1
cl.talk("Hello")       // C1 talk: Hello    
cl.c2.c3.talk("Hello") // C1.talk: C3.talk: World
```

如果没有自类型标记，我们就无法直接从 C3.talk 中调用 C1 talk，因为二者名称相同，后者将屏蔽前者，而且 C3 也不是 C1 的直接子类，所以也不能调用 super.talk。

可以将其认为是一个**指向固定位置的 this 引用**。

功能二：声明某特征/类必须引入另一特征/类

```scala
trait User {
  def username: String
}

trait Tweeter {
  // 注意这一行
  // 这一行将 this 的类型指定为 User
  // 此时这个 trait 相当于变成了 User 的子特征，可以使用 User 中的元素了
  this: User =>
  def tweet(tweetText: String) = println(s"$username: $tweetText")
}

// 但同时，使用 Tweeter 这个特征就必须同时引入 User 这个特征
class VerifiedTweeter(val username_ : String) extends Tweeter with User {
  def username = s"real $username_"
}

val realBeyoncé = new VerifiedTweeter("Beyoncé")
realBeyoncé.tweet("Just spilled my glass of lemonade")  // prints "real Beyoncé: Just spilled my glass of lemonade"
```

自类型标记可以将一个特征/类 A 指定为另一个特征/类 B 的子特征/类，从而使用 B 中对应的功能，但引入这个被修改的特征/类时就必须同时引入 B 类。同理，此处的 this 关键字也可以替换成其他名称。
