---
layout: post
title: Scala 类型系统02：抽象类型与自类型标记
---
> 参数化类型在静态的，面向对象的语言中很常见。除了参数化类型，Scala 还支持抽象类型，这在函数式语言中很常见。

## 1 抽象类型

```scala
// 抽象类型用 type 关键字声明
trait exampleTrait {
  type t1               // 一个普通的没有约束的抽象类型
  type t2 >: t3 <: t1   // t2 必须是 t3 的父类，t1 的子类
  type t3 <: t1         // t3 必须是 t1 的子类
  type t4 <: Seq[t1]    // t4 必须是元素为 t1 的序列的子类
  // type t5 = +AnyRef  // ❌错误 不能在此使用变异标记
  
  val v1: t1  // t1 定义后才能初始化
  val v2: t2  // 同上
 	...
}
```

这里声明了 t1，t2，t3 的关系：

* t2 声明表明他必须处于 t1 和 t3 的“中间”
* 无论 t1 是什么类型，必须是 t2 的超类（或等于 t2）
* 而 t3 必须被设定为 t2 的子类（或等于 t2）
* 为了与 t2 声明保持一致，t3 必须声明为 t1 的子类型。
  * 如果省略类型边界的标记，就会引发错误
  * 因为定义 t2 时已经推断出 t3 <: t1 此时使用 t3 <: t2 会在 t2 >: t3 <: t1 引发错误（对 t2 的非法循环引用）
  * 所以此时不能省略 t3 的类型声明，也不能认为 t3 可以从 t2 的类型声明中推断得到。
  * 当然这只是为了演示而编写的特例，实际生产中不一定需要这么复杂的情况。

定义一些 trait 和一个类来测试一下这些类型: 

```scala
trait T1 { val name1: String }
trait T2 extends T1 { val name2: String }
case class C(name1: String, name2: String) extends T2
```

最后，我们可以定义一个具体类型，定义抽象类型成员，并初始化相应的值:

```scala
object example extends exampleTrait {
  type t1 = T1
  type t2 = T2
  type t3 = C
  type t4 = Vector[T1]
  
  val v1 = new T1 { val name1 = "T1"}
  val v2 = new T2 { val name1 = "T1"; val name2 = "T2"
  val v3 = C("1", "2")
  val v4 = Vector(C("3", "4"))
}
```

> **什么时候使用何种类型**
>
> 从技术上讲，参数化类型和抽象类型之间可以相互替换，你可以用参数化类型表示任意抽象类型，反之亦然。然而在事件中，不同的特征适合处理不同的设计问题。
>
> * 参数化类型可以很好的用于容器中，如集合。而类型参数所表示的元素类型与容器本身并没有什么联系。例如：List[String], List[Int], List[Double] 的工作方式相同。
>
>   * 如果换成抽象类型会如何？以 Some 容器为例：  
>
>     ```scala
>     // 原始声明：
>     case final class Some[+A](val value : A) { ... }
>     // 如果换成抽象类型：
>     case final class Some(val value : ???) {
>       type A
>       ... 
>     }
>     ```
>
>     参数 value 应该用什么类型呢？我们不能使用 A，因为它不在构造器参数列表的作用域内。 我们虽然可以用 Any，但这样就违背了类型安全的目的。 
>
>     **所以，当类型的参数用于构造器时，唯一合适的选择就是参数化类型。**
>
> * 反过来，抽象类型在相互密切联系的 “类型家族” 中也非常有用。
>
>   * ```scala
>     import java.io._
>     abstract class BulkReader {
>       type In
>       val source: In
>       def read: String  // Read and return a String
>     }
>     class StringBulkReader(val source: String) extends BulkReader {
>       type In = String
>       def read: String = source
>     }
>     class FileBulkReader(val source: File) extends BulkReader {
>       type In = File
>       def read: String = {...}
>     }
>     ```
>
>   * 可以看出，此时类如何运作取决于传入的类型（String 还是 File），所以此时，抽象类型是不二选择

## 2 自类型标记

>  我们可以用 this 来指代调用该方法的实例。一般情况下，我们不需要显示地使用 this，但如果作用域内存在同名变量时，显示使用 this 有助于消除二义性。
>
>  `自类型标记 (self-type annotation )`可以帮助我们完成两件事：
>
>  * 创建 this 的别名
>  * 声明某特征/类必须引入另一特征/类

先来看第一点，自类型标记可以起到为 this 起别名的功能：

```scala
// 下文的 self v 并不是关键字，可以把它换成任何合法的关键字
class C1 { self =>
  def talk(message: String) = println(s"C1 talk: $message")
  class C2 {
    class C3 {
      def talk(message: String) = self.talk(s"C3 talk: $message")
    }
  }
}

val c1 = new C1
cl.talk("Hello")       // C1 talk: Hello    
cl.c2.c3.talk("Hello") // C1.talk: C3.talk: World
```

如果没有自类型标记，我们就无法直接从 C3.talk 中调用 C1 talk，因为二者名称相同，后者将屏蔽前者，而且 C3 也不是 C1 的直接子类，所以也不能调用 super.talk。

可以将其认为是一个**指向固定位置的 this 引用**。

功能二：声明某特征/类必须引入另一特征/类

```scala
trait User {
  def username: String
}

trait Tweeter {
  // 注意这一行
  // 这一行将 this 的类型指定为 User
  // 此时这个 trait 相当于变成了 User 的子特征，可以使用 User 中的元素了
  this: User =>
  def tweet(tweetText: String) = println(s"$username: $tweetText")
}

// 但同时，使用 Tweeter 这个特征就必须同时引入 User 这个特征
class VerifiedTweeter(val username_ : String) extends Tweeter with User {
  def username = s"real $username_"
}

val realBeyoncé = new VerifiedTweeter("Beyoncé")
realBeyoncé.tweet("Just spilled my glass of lemonade")  // prints "real Beyoncé: Just spilled my glass of lemonade"
```

自类型标记可以将一个特征/类 A 指定为另一个特征/类 B 的子特征/类，从而使用 B 中对应的功能，但引入这个被修改的特征/类时就必须同时引入 B 类。同理，此处的 this 关键字也可以替换成其他名称。
